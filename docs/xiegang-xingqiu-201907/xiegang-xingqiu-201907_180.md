# 推荐一本 Java 并

# 推荐一本 Java 并

小猿 : 推荐一本 Java 并发编程的好书，目录如下： 第一章并发 编程的挑战 1 1.1 上下文切换 1 1.1.1 多线程一定快吗 1 1.1.2 测试 上下文切换次数和时长 3 1.1.3 如何减少上下文切换 3 1.1.4 减少 上下文切换实战 4 1.2 死锁 5 1.3 资源限制的挑战 6 1.4 本章小结 7 第二章 Java 并发机制的底层实现原理 8 2.1volatile 的应用 8 2.2synchronized 的实现原理与应用 11 2.2.1Java 对象头 12 2.2.2 锁 的升级与对比 13 2.3 原子操作的实现原理 16 2.4 本章小结 20 第三章 Java 内存模型 21 3.1Java 内存模型的基础 21 3.1.1 并发编程模 型的两个关键问题 21 3.1.2Java 内存模型的抽象结构 22 3.1.3 从 源代码到指令序列的重排序 23 3.1.4 并发编程模型的分类 24 3.1.5happens—before 简介 26 3.2 重排序 27 3.2.1 数据依赖性 28 3.2.2as—if—serial 语义 28 3.2.3 程序顺序规则 29 3.2.4 重排序对 多线程的影响 29 3.3 顺序一致性 31 3.3.1 数据竞争与顺序一致 性 31 3.3.2 顺序一致性内存模型 32 3.3.3 同步程序的顺序一致性 效果 34 3.3.4 未同步程序的执行特性 35 3.4volatile 的内存语义 38 3.4.1volatile 的特性 38 3.4.2volatile 写—读建立的 happens—before 关系 39 3.4.3volatile 写—读的内存语义 40 3.4.4volatile 内存语义 的实现 42 3.4.5JSR—133 为什么要增强 volatile 的内存语义 46 3.5 锁的内存语义 47 3.5.1 锁的释放—获取建立的 happens—before 关系 47 3.5.2 锁的释放和获取的内存语义 48 3.5.3 锁内存语义的 实现 50 3.5.4concurrent 包的实现 54 3.6final 域的内存语义 55 3.6.1final 域的重排序规则 55 3.6.2 写 final 域的重排序规则 56

3.6.3 读 final 域的重排序规则 57 3.6.4final 域为引用类型 58 3.6.5 为什么 final 引用不能从构造函数内“溢出”59 3.6.6final 语义在处 理器中的实现 61 3.6.7JSR—133 为什么要增强 f？inal 的语义 62 3.7happens—before62 3.7.1JMM 的设计 62 3.7.2happens—before 的定义 64 3.7.3happens—before 规则 65 3.8 双重检查锁定与延迟 初始化 67 3.8.1 双重检查锁定的由来 67 3.8.2 问题的根源 69 3.8.3 基于 volatile 的解决方案 71 3.8.4 基于类初始化的解决方案

72 3.9Java 内存模型综述 78 3.9.1 处理器的内存模型 78 3.9.2 各 种内存模型之间的关系 80 3.9.3JMM 的内存可见性保证 80 3.9.4JSR—133 对旧内存模型的修补 81 3.10 本章小结 82 第四章 Java 并发编程基础 83 4.1 线程简介 83 4.1.1 什么是线程 83 4.1.2 为什么要使用多线程 84 4.1.3 线程优先级 85 4.1.4 线程的状态 87 4.1.5Daemon 线程 90 4.2 启动和终止线程 91 4.2.1 构造线程 91

4.2.2 启动线程 92 4.2.3 理解中断 92 4.2.4 过期的 suspend（）、 resume（）和 stop（）93 4.2.5 安全地终止线程 95 4.3 线程间通 信 96 4.3.1volatile 和 synchronized 关键字 96 4.3.2 等待/通知机制 98 4.3.3 等待/通知的经典范式 101 4.3.4 管道输入/输出流 102

4.3.5Thread.join（）的使用 103 4.3.6ThreadLocal 的使用 105 4.4 线程应用实例 106 4.4.1 等待超时模式 106 4.4.2 一个简单的数据 库连接池示例 106 4.4.3 线程池技术及其示例 110 4.4.4 一个基于 线程池技术的简单 Web 服务器 114 4.5 本章小结 118 第五章 Java 中的锁 119 5.1Lock 接口 119 5.2 队列同步器 121 5.2.1 队列同步 器的接口与示例 121 5.2.2 队列同步器的实现分析 124 5.3 重入 锁 136 5.4 读写锁 140 5.4.1 读写锁的接口与示例 141 5.4.2 读写锁 的实现分析 142 5.5LockSupport 工具 146 5.6Condition 接口 147 5.6.1Condition 接口与示例 148 5.6.2Condition 的实现分析 150 5.7 本章小结 154 第六章 Java 并发容器和框架 155 6.1ConcurrentHashMap 的实现原理与使用 155 6.1.1 为什么要使 用 ConcurrentHashMap155 6.1.2ConcurrentHashMap 的结构 156 6.1.3ConcurrentHashMap 的初始化 157 6.1.4 定位 Segment159 6.1.5ConcurrentHashMap 的操作 160 6.2ConcurrentLinkedQueue161 6.2.1ConcurrentLinkedQueue 的结 构 162 6.2.2 入队列 162 6.2.3 出队列 165 6.3Java 中的阻塞队列 167 6.3.1 什么是阻塞队列 167 6.3.2Java 里的阻塞队列 168 6.3.3 阻塞队列的实现原理 172 6.4Fork/Join 框架 175 6.4.1 什么是 Fork/Join 框架 175 6.4.2 工作窃取算法 176 6.4.3Fork/Join 框架的 设计 177 6.4.4 使用 Fork/Join 框架 177 6.4.5Fork/Join 框架的异常 处理 179 6.4.6Fork/Join 框架的实现原理 179 6.5 本章小结 181 第七章 Java 中的 13 个原子操作类 182 7.1 原子更新基本类型类 182

7.2 原子更新数组 184 7.3 原子更新引用类型 185 7.4 原子更新字 段类 187 7.5 本章小结 188 第八章 Java 中的并发工具类 189 8.1 等 待多线程完成的 CountDownLatch189 8.2 同步屏障 CyclicBarrier191 8.2.1CyclicBarrier 简介 191 8.2.2CyclicBarrier 的 应用场景 193 8.2.3CyclicBarrier 和 CountDownLatch 的区别 195 8.3 控制并发线程数的 Semaphore196 8.4 线程间交换数据的 Exchanger198 8.5 本章小结 199 第九章 Java 中的线程池 200 9.1 线 程池的实现原理 200 9.2 线程池的使用 203 9.2.1 线程池的创建 203 9.2.2 向线程池提交任务 205 9.2.3 关闭线程池 205 9.2.4 合理 地配置线程池 206 9.2.5 线程池的监控 206 9.3 本章小结 207 第十章 Executor 框架 208 10.1Executor 框架简介 208 10.1.1Executor 框 架的两级调度模型 208 10.1.2Executor 框架的结构与成员 208 10.2ThreadPoolExecutor 详解 213 10.2.1FixedThreadPool 详解 213 10.2.2SingleThreadExecutor 详解 214 10.2.3CachedThreadPool 详 解 215 10.3ScheduledThreadPoolExecutor 详解 217 10.3.1ScheduledThreadPoolExecutor 的运行机制 217 10.3.2ScheduledThreadPoolExecutor 的实现 218 10.4FutureTask 详解 221 10.4.1FutureTask 简介 222 10.4.2FutureTask 的使用 222 10.4.3FutureTask 的实现 224 10.5 本章小结 227 第十一章 Java 并发 编程实践 228 11.1 生产者和消费者模式 228 11.1.1 生产者消费 者模式实战 229 11.1.2 多生产者和多消费者场景 231 11.1.3 线程 池与生产消费者模式 234 11.2 线上问题定位 234 11.3 性能测试 236 11.4 异步任务池 238 11.5 本章小结 240

2018-07-11